case class RelationMetaData(attributes: Map[String, String], name: String, typeName: String)

import scala.util.Random

object CodeGeneration {
  def apply(physical: Physical, varName: String) = {
    def genCode(physical: Physical, relMeta: RelationMetaData): (String, RelationMetaData) = {
      physical match {
        case RangeScan(meta, from, to) => rangeScan(meta, from, to)
        case IndexLookup(meta, map) => indexLookup(meta, map)
        case Filter(expr, from) =>
          val x = genCode(from, relMeta)
          val y = filter(x._2, expr)
          (x._1 + y._1, y._2)
        case OnePassProj(exprList, from) =>
          val x = genCode(from, relMeta)
          val y = onePassProj(x._2, exprList)
          (x._1 + y._1, y._2)
      }
    }
    genCode(physical, RelationMetaData(Map(), "", "")) match {
      case (code, n) =>
        "//GENERATED BY JAQCO\n" + code + s"auto $varName = tmp${n.name}"
    }
  }

  def genName(): String = {
    Random.alphanumeric.take(10).mkString
  }

  def filter(meta: RelationMetaData, expr: Expr): (String, RelationMetaData) = {
    val oldListName = s"${meta.name}"
    val listType = s"${meta.typeName}"
    val newListName = s"${oldListName}_filter"
    val iterator = s"i"
    val code = s"""
// filter
std::vector<${listType}> ${newListName};
for (const auto &${iterator} : ${oldListName}) {
  if (${condTrans(expr, meta)}) {
    ${newListName}.push_back(${iterator});
  }
}

"""
    (code, RelationMetaData(meta.attributes, newListName, meta.typeName))
  }

  def rangeScan(meta: TableMetaData, from: RangeVal, to: RangeVal) = {
    def conv(value: RangeVal, meta: TableMetaData): String = {
      value match {
        case ConstVal(x) => x.toString
        case ZeroVal() => "zeroVal"
        case MaxVal() => "MaxVal"
      }
    }
    val relName = s"${meta.relName}"
    val listName = s"${relName}_${genName()}"
    val push = s"${listName}_push"
    val pushType = s"${push}_type"
    val index = s"${listName}_index"
    val fromString = s"${listName}_from_string"
    val toString = s"${listName}_to_string"
    val valType = s"${listName}_type"
    val code =s"""
auto ${index} = get_index(${relName});
${pushType} ${push};
tpcc::order_line_key k_ol_start { w_id, d_id, o_id, 0 };
const auto& ${fromString} = reactdb::utility::encode_safe(k_ol_start);
tpcc::order_line_key k_ol_end { w_id, d_id, o_id, std::numeric_limits<
        tpcc::id_type>::max() };
const auto& ${toString} = reactdb::utility::encode_safe(k_ol_end);
order_line_table->range_scan(k_ol_start_string, &k_ol_end_string,
        order_line_scan_op);
auto ${listName} = std::get(push.vec)
"""
    ("\n//range scan" + code, RelationMetaData(meta.attributes, listName, valType))
  }

  def condTrans(expr: Expr, relMeta: RelationMetaData): String = {
    def trans(expr: Expr): String = {
      expr match {
        case Attribute(attName) if relMeta.attributes.keys.toList.contains(attName) =>
          relMeta.name + "." + attName
        case Attribute(attName)   => attName
        case Less(left, right)    => "("  + trans(left) + " < "  + trans(right) + ")"
        case Leq(left, right)     => "("  + trans(left) + " <= " + trans(right) + ")"
        case Greater(left, right) => "("  + trans(left) + " > "  + trans(right) + ")"
        case Geq(left, right)     => "("  + trans(left) + " >= " + trans(right) + ")"
        case Equals(left, right)  => "("  + trans(left) + " == " + trans(right) + ")"
        case Plus(left, right)    => "("  + trans(left) + " + "  + trans(right) + ")"
        case Minus(left, right)   => "("  + trans(left) + " - "  + trans(right) + ")"
        case And(left, right)     => "("  + trans(left) + " && " + trans(right) + ")"
        case Or(left, right)      => "("  + trans(left) + " || " + trans(right) + ")"
        case Not(value)           => "!(" + trans(value) + ")"
        case x: Const             => x.value.toString
      }
    }
    trans(expr)
  }

  def indexLookup(meta: TableMetaData, map: Map[String, Expr]) = {
    val relName  = s"${meta.relName}"
    val listName = s"${relName}_${genName()}"
    val keyStruct = s"${listName}_key"
    val keyType = s"${relName}_key_type"
    val valueString = s"${listName}_value_string"
    val keyStructCreate =
      map.foldLeft("") ( (acc, ex) =>
        acc + keyStruct + "." + ex._1 + " = " + condTrans(ex._2, RelationMetaData(Map(),"","")) + ";\n")
    val valStruct = s"${relName}_value"
    val valType = s"${listName}_type"
    val index = s"${listName}_index"
    val code = s"""
//index lookup
auto $index = get_index($relName);
std::string ${valueString};
$keyType $keyStruct;
$keyStructCreate
std::vector<${valType}> $listName;

if ($index->get(utility::encode_safe($keyStruct), ${valueString})) {
  $valType $valStruct;
  utility::decode_safe(${valueString}, ${valStruct});
  ${listName}.push_back(${valStruct});
}
"""
    (code, RelationMetaData(meta.attributes, listName, valType))
  }

  def typeLookup(valName: String, meta: RelationMetaData) = {
    // TODO: Should be done properly when operations on multiple relations are added
    (meta.attributes get valName) match {
      case None => throw new Error(s"Type for variable $valName could not be found")
      case Some(varType) => varType
    }
  }
  def onePassProj(meta: RelationMetaData, exprList: List[Expr]) = {
    def createRelMeta(exprList: List[Expr], map: Map[String, String]): Map[String, String] = {
      exprList match {
        case Nil => map
        case x :: xs =>
          val name = getVarName(x)
          createRelMeta(xs, map) + (name -> typeLookup(name, meta))
      }
    }
    def getVarName(expr: Expr) = {
      expr match {
        case Attribute(attName) => attName
        case LongConst(value)   => s"long0"
        case StringConst(value) => s"string0"
        case _ => "" //fail here
      }
    }
    val reg = meta.name
    val outReg = reg + "1"
    val oldListName = s"tmp${reg}"
    val newListName = s"tmp${outReg}"
    val oldTypeName = oldListName + "_type"
    val newTypeName = newListName + "_type"
    val itr = "i"
    val struct = s"struct ${newTypeName} {\n" +
    exprList.foldLeft("") ( (acc, ex) => acc + typeLookup(getVarName(ex), meta) + " " + getVarName(ex) + ";\n" ) +
    "}MACRO_PACKED;\n"
    val code = s"""
std::vector<${newTypeName}> ${newListName};
for (uint $itr = 0; $itr < ${oldListName}.size(); $itr++) {
  auto ${oldListName}_$itr = ${oldListName}[$itr];
  ${newTypeName} ${newListName}_$itr;
${exprList.foldLeft("") ((acc, ex) => acc + ("  " + newListName + "_" + itr + "." + getVarName(ex) + " = " + oldListName + "_" + itr + "." + getVarName(ex) + ";\n"))}
  ${newListName}.push_back(${newListName}_$itr);
}
"""
    ("//projection \n" + struct + code, RelationMetaData(Map(), "s", "o"))
  }
}
